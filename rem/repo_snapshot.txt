This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
data/
  entities.csv
graph/
  __init__.py
  entities.py
  graph.py
  nodes.py
  state.py
rem/
  scripts/
    __init__.py
    fill_detected_entity.py
  __init__.py
  cases.csv
  README.md
.gitignore
LICENSE
main.py
README.md
requirements.txt
test_contract.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="rem/scripts/__init__.py">

</file>

<file path="rem/scripts/fill_detected_entity.py">
"""Rellena detected_entity en rem/cases.csv ejecutando el grafo."""
import csv
from pathlib import Path

from graph.graph import app

CSV_PATH = Path(__file__).parent.parent / "cases.csv"


def main():
    rows = []
    with open(CSV_PATH, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        fieldnames = reader.fieldnames
        for row in reader:
            url = row.get("url", "").strip()
            detected = ""
            if url:
                try:
                    result = app.invoke({"url": url})
                    detected = result.get("entity", {}).get("entity_id", "") or ""
                except Exception:
                    detected = ""
            row["detected_entity"] = detected
            rows.append(row)

    with open(CSV_PATH, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(rows)


if __name__ == "__main__":
    main()
</file>

<file path="rem/__init__.py">

</file>

<file path="graph/entities.py">
import csv
from pathlib import Path

ENTITY_LOOKUP = {}
ENTITY_NAMES = {}

csv_path = Path(__file__).resolve().parent.parent / "data" / "entities.csv"

with open(csv_path, newline="", encoding="utf-8") as f:
    reader = csv.DictReader(f)
    for row in reader:
        entity_id = row["entity_id"]
        token = row["token"].lower()
        name = row["entity_name"]

        ENTITY_LOOKUP[token] = entity_id
        ENTITY_NAMES[entity_id] = name
</file>

<file path="rem/cases.csv">
url,detected_entity,expected_entity,notes
url,,expected_entity,notes
http://particulares-bancosantander-es.tempurl.host/es/grupo/home/codigo_incorrecta.php,santander,santander,priorizada por scoring; ambigüedad esperable
http://loc52.caixabank.es.lacaixa.actualizar.information.ay-min.az/soporte-directonow/home/Espera.html,caixabank,caixabank,brand en subdominio; colisiones posibles
http://oficinacorreos.page.link/es,correos,correos,shortener; hosting externo
https://bbva.es.suspension-tarjeta.com,bbva,bbva,brand en dominio; patrón común
</file>

<file path="rem/README.md">
Esta carpeta contiene artefactos offline para revisión humana y análisis LLM.
No forma parte del sistema activo ni del flujo LangGraph.
Ningún output del revisor offline se aplica automáticamente.
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2026 AlexusPacicus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="test_contract.py">
"""
Tests de contrato v3
====================
Validan SOLO el contrato de salida.
Deben pasar ANTES y DESPUÉS del refactor.
"""
import pytest
from graph.graph import app


def validate_entity_invariants(entity):
    """Valida los invariantes del contrato de salida."""
    assert "entity_detected" in entity, "entity_detected siempre presente"
    assert isinstance(entity["entity_detected"], bool)
    
    if entity["entity_detected"]:
        assert entity["entity_id"] is not None, "entity_id ≠ None cuando detected"
        assert entity["entity_name"] is not None, "entity_name ≠ None cuando detected"
    else:
        assert entity["entity_id"] is None, "entity_id == None cuando no detected"
        assert entity["entity_name"] is None, "entity_name == None cuando no detected"


def is_abort(state):
    """Determina si el estado es un abort."""
    return (
        state.get("abort_reason") is not None or
        len(state.get("violations", [])) > 0
    )


class TestContractHappyPath:
    """Test: entidad detectada"""
    
    def test_entity_detected_bbva(self):
        state = app.invoke({"url": "http://bbva-login.com"})
        
        assert state.get("abort_reason") is None
        assert state.get("violations", []) == []
        assert state["entity"] is not None
        validate_entity_invariants(state["entity"])
        assert state["entity"]["entity_detected"] is True
        assert state["entity"]["entity_id"] == "bbva"
        assert state["entity"]["entity_name"] == "BBVA"
    
    def test_entity_detected_correos(self):
        state = app.invoke({"url": "http://correos-aviso.com"})
        
        assert state.get("abort_reason") is None
        assert state.get("violations", []) == []
        assert state["entity"] is not None
        validate_entity_invariants(state["entity"])
        assert state["entity"]["entity_detected"] is True
        assert state["entity"]["entity_id"] == "correos"


class TestContractNoEntity:
    """Test: sin entidad detectada"""
    
    def test_no_entity_detected(self):
        state = app.invoke({"url": "http://login-seguro.com"})
        
        assert state.get("abort_reason") is None
        assert state.get("violations", []) == []
        assert state["entity"] is not None
        validate_entity_invariants(state["entity"])
        assert state["entity"]["entity_detected"] is False
        assert state["entity"]["entity_id"] is None
        assert state["entity"]["entity_name"] is None


class TestContractAbort:
    """Test: input inválido → abort limpio"""
    
    def test_empty_url(self):
        state = app.invoke({"url": ""})
        
        assert is_abort(state), "debe ser abort"
        assert state.get("entity") is None, "entity debe ser None en abort"
    
    def test_missing_url(self):
        state = app.invoke({})
        
        assert is_abort(state), "debe ser abort"
        assert state.get("entity") is None, "entity debe ser None en abort"
    
    def test_invalid_url_type(self):
        state = app.invoke({"url": 123})
        
        assert is_abort(state), "debe ser abort"
        assert state.get("entity") is None, "entity debe ser None en abort"
</file>

<file path="graph/__init__.py">

</file>

<file path="requirements.txt">
langgraph
pytest
</file>

<file path="data/entities.csv">
entity_id,entity_name,token,notes,source
bbva,BBVA,bbva,,manual  
santander,Santander,santander,,manual
caixabank,CaixaBank,caixa,,manual
sabadell,Sabadell,sabadell,,manual
dgt,DGT,dgt,,manual
sepe,SEPE,sepe,,manual
aeat,AEAT,aeat,,manual
iberdrola,Iberdrola,iberdrola,,manual
gasnatural,Gas Natural,gasnatural,,manual
correos,Correos,correos,,manual
seur,SEUR,seur,,manual
telefonica,Telefónica,telefonica,,manual
</file>

<file path="graph/nodes.py">
from .entities import ENTITY_LOOKUP, ENTITY_NAMES


def validate_input(state):
    """Valida input. Retorna input y/o abort_reason."""
    url = state.get("url")
    
    if not isinstance(url, str) or not url.strip():
        return {
            "input": None,
            "abort_reason": "url missing or invalid"
        }
    
    return {"input": {"url": url}}


def detector_mecanico(state):
    """Detecta entidad. Retorna solo entity."""
    input_data = state.get("input")
    if input_data is None:
        return {}
    
    url = input_data.get("url", "")
    url_lower = url.lower()
    
    for token, entity_id in ENTITY_LOOKUP.items():
        if token in url_lower:
            return {
                "entity": {
                    "entity_detected": True,
                    "entity_id": entity_id,
                    "entity_name": ENTITY_NAMES.get(entity_id)
                }
            }
    
    return {
        "entity": {
            "entity_detected": False,
            "entity_id": None,
            "entity_name": None
        }
    }


def finalize(state):
    """Valida contrato. Retorna violations si falla."""
    if state.get("abort_reason") or state.get("violations"):
        return {}
    
    entity = state.get("entity")
    if entity is None:
        return {}
    
    violations = []
    
    if "entity_detected" not in entity:
        violations.append("entity_detected ausente")
    else:
        detected = entity.get("entity_detected")
        eid = entity.get("entity_id")
        ename = entity.get("entity_name")
        
        if detected:
            if eid is None:
                violations.append("entity_id es None con detected=True")
            if ename is None:
                violations.append("entity_name es None con detected=True")
        else:
            if eid is not None:
                violations.append("entity_id no es None con detected=False")
            if ename is not None:
                violations.append("entity_name no es None con detected=False")
    
    if violations:
        return {"violations": violations}
    
    return {}
</file>

<file path=".gitignore">
venv/
__pycache__/
*.pyc
.env
.DS_Store
lecciones.md
</file>

<file path="main.py">
from graph.graph import app

tests = [
    "http://bbva-login.com",
    "http://login-seguro.com",
    "http://bbvaseguro.com",
    "http://correos-aviso.com",
    "",  # inválido
]

for url in tests:
    print("TEST:", url)
    state = {"url": url} if url else {}
    print(app.invoke(state))
    print("-" * 40)
</file>

<file path="graph/graph.py">
from langgraph.graph import StateGraph, END
from .state import State
from .nodes import validate_input, detector_mecanico, finalize

graph = StateGraph(State)

# nodos
graph.add_node("validate_input", validate_input)
graph.add_node("detector_mecanico", detector_mecanico)
graph.add_node("finalize", finalize)

# entry
graph.set_entry_point("validate_input")

# gate duro: si abort → END
graph.add_conditional_edges(
    "validate_input",
    lambda s: "__end__" if s.get("abort_reason") or s.get("violations") else "detector_mecanico",
    {
        "detector_mecanico": "detector_mecanico",
        "__end__": END
    }
)

# flujo lineal
graph.add_edge("detector_mecanico", "finalize")
graph.add_edge("finalize", END)

app = graph.compile()
</file>

<file path="graph/state.py">
"""
CONTRATO DE SALIDA v3

CASO ÉXITO (sin abort):
- abort_reason is None
- violations == []
- entity presente y cumple invariantes:
  - entity_detected siempre presente (bool)
  - si True  -> entity_id y entity_name no-None
  - si False -> entity_id y entity_name None

CASO ABORT:
- abort_reason poblado o violations != []
- entity == None
"""
from typing import TypedDict, Optional


# total=False: campos opcionales durante el grafo; el contrato aplica al estado final.
class State(TypedDict, total=False):
    url: Optional[str]            # Entrada raw (entrypoint)
    input: Optional[dict]         # Entrada validada (ej: {"url": "..."})
    entity: Optional[dict]        # Resultado de detección (entity_detected, entity_id, entity_name)
    violations: list              # Violaciones de invariantes (irrecuperables)
    abort_reason: Optional[str]   # Razón de abort si aplica
</file>

<file path="README.md">
# sector_entidad_lang

Este proyecto implementa un flujo determinista basado en **LangGraph** para identificar entidades a través de sus URLs. El sistema analiza una dirección web, localiza tokens predefinidos en ella y devuelve la entidad asociada de forma estructurada y predecible.

## Propósito y Alcance

Para garantizar la precisión técnica, es fundamental definir los límites del sistema:

### Qué NO hace el sistema
*   **No es un detector de phishing:** No evalúa la seguridad de la URL.
*   **No prioriza alertas:** No gestiona la criticidad de los eventos.
*   **No usa IA:** No utiliza Machine Learning ni Modelos de Lenguaje (LLMs).
*   **No clasifica:** No realiza scoring ni categorización de datos.

### Exclusiones específicas de la v3
En esta versión no se incluye lógica de sectores, sistemas de puntuación, integraciones con LLMs ni abstracciones adicionales que no formen parte de la detección mecánica principal.

## Input

Diccionario con una clave `url` de tipo string.

```python
{"url": "http://ejemplo.com"}
```

## Output (Contrato v3)

### Caso exito (sin abort)

```python
{
    "entity": {
        "entity_detected": True,   # o False
        "entity_id": "bbva",       # o None si detected=False
        "entity_name": "BBVA"      # o None si detected=False
    },
    "abort_reason": None,
    "violations": []
}
```

**Invariantes:**
- `entity.entity_detected` siempre presente (bool)
- Si `True` → `entity_id` y `entity_name` no-None
- Si `False` → `entity_id` y `entity_name` None

### Caso abort

```python
{
    "entity": None,
    "abort_reason": "url missing or invalid",  # o violations != []
    "violations": []
}
```

## Como funciona (v3)

El grafo ejecuta los siguientes nodos:

1. **validate_input** - Valida que `url` sea string valido. Retorna `input` o `abort_reason`.
2. **[gate]** - Si `abort_reason` o `violations` → END.
3. **detector_mecanico** - Busca tokens en la URL. Retorna `entity`.
4. **finalize** - Valida invariantes del contrato. Retorna `violations` si falla.

## Invariantes del sistema

- **Nodos puros**: no mutan estado, retornan deltas.
- **Gates**: solo leen flags, no computan.
- **Determinismo**: mismo input → mismo output (sin timestamps/UUIDs en contrato).
- **Defensividad**: accesos con `.get()`, cero excepciones por datos.

## Guía de Inicio Rápido

### Instalación y Ejecución
Para configurar el entorno y ejecutar el flujo principal:

```bash
pip install -r requirements.txt
python main.py
```

### Verificación del Contrato
Para asegurar que el sistema respeta los invariantes y el esquema de salida definido:

```bash
pytest test_contract.py -v
```
</file>

</files>
